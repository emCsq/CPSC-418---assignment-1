/***********************************************************
* Name: Emily Chow
* Course: CPSC 418					Term: Fall 2014
* Assignment: 1
*
* Class name: secureFile.java
*
* Brief Description of File: The purpose of this program is to take in a user-designated
* input and encrypt it such that it cannot be read. The user provides a 'seed' that will 
* serve as the password for the file. A message digest is created from the input file and
* concatenated with the input file, and that is thrown through the encryption algorithm
* before being written back into a new file.
*
************************************************************/
import javax.crypto.*;
import javax.crypto.spec.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.security.SecureRandom;
import java.io.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.security.MessageDigest;

public class secureFile {
	private static KeyGenerator keyGenerate = null;
	private static KeyGenerator newKeyGenerate = null;
	private static SecretKey realSecretKey = null;
	private static SecretKeySpec secretKeySpec = null;
	private static Cipher secretCipher = null;
	private static SecureRandom secRan = null;
	private static FileInputStream inFile = null;
	private static FileOutputStream outFile = null;

	public static void main (String[] args) throws Exception{
		try {
			if (args.length != 3) {
			System.out.println("incorrect input.\n Please type 'java secureFile [name_of_encrypt_file] [name_of_decrypt_file] [seed]");
			System.exit(0);
		}
			//open files + turn seed into an array of bytes
			inFile = new FileInputStream(args[0]);
			outFile = new FileOutputStream(args[1]);
			byte[] seed = args[2].getBytes();
			
			//input file becomes a byte array
			byte[] itemToEncrypt = new byte[inFile.available()];
			int readBytes = inFile.read(itemToEncrypt);
					
			//generate the 128 bit key using the secureRandom
			keyGenerate = KeyGenerator.getInstance("AES");
			secRan = SecureRandom.getInstance("SHA1PRNG");
			secRan.setSeed(seed);
			keyGenerate.init(128, secRan);
			realSecretKey = keyGenerate.generateKey();

			//create message digest from the input file
			byte[] md; 
			MessageDigest sha = MessageDigest.getInstance("SHA1");
			md = sha.digest(itemToEncrypt);

			//concatenates the original file with the message digest that will be sent
			//through encryption later
			byte[] combinationMessageAndDigest = new byte[itemToEncrypt.length + md.length];
			System.arraycopy(itemToEncrypt, 0, combinationMessageAndDigest, 0, itemToEncrypt.length);
			System.arraycopy(md, 0, combinationMessageAndDigest, itemToEncrypt.length, md.length);
			
			//builds the initialization vector specs generated by using the secureRandom generator
			//that has the seed set as the seed taken in from the user
			//This is necessary for CBC encryption
			byte[] iv = new byte[16];
			
			//get key material
			byte[] temKey = realSecretKey.getEncoded();
			secretKeySpec = new SecretKeySpec(temKey, "AES");
			
			//create cipher object that'll implement AES-CBC algorithm
			secretCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
			
			//do encryption on the file+digest and stores it into returningBytes
			byte[] returningBytes = null;
			secretCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, new IvParameterSpec(iv));
			returningBytes = secretCipher.doFinal(combinationMessageAndDigest);
			
			System.out.println("blah: " + combinationMessageAndDigest.length);
			
			//writes the result back into file
			outFile.write(returningBytes);
			
			//a message that informs the user that the encryption was performed successfully
			System.out.println("\n===ENCRYPTION WAS SUCCESSFUL!===");
			
		} catch (Exception e) {
			System.out.println("\nError occurred. The error is stated to be: " + e);
		} finally {
			if (inFile != null) {
				inFile.close();
			}
			if (outFile != null) {
				outFile.close();
			}
		}
	}

}
